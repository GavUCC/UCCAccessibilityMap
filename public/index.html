<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>OSM + Leaflet Quickstart</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link
            rel="stylesheet"
            href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
            integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
            crossorigin=""
    />
    <style>
        html, body, #map { height: 100%; margin: 0; }
        .search { position: absolute; top: 10px; left: 10px; z-index: 1000;
                  background: white; padding: 8px; border-radius: 6px; }
    </style>
</head>
<body>
    <div class="search">
        <input id="q" placeholder="Search (Nominatim)" size="30" />
        <button id="searchBtn">Search</button>
    </div>
    <div id="map"></div>

    <script
        src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""
    ></script>
    <script>
    // 1) Init map (center on Cork, IE as an example)
        const map = L.map('map').setView([51.8986, -8.4756], 13);

    // 2) Basemap tiles: Use a provider meant for apps (replace with your provider URL + key)
    // Example: https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png (community), light usage only.
    // Prefer a commercial/hosted tile service for production.
        const tiles = L.tileLayer(
        'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
        {
        maxZoom: 19,
        attribution:
          '&copy; OpenStreetMap contributors'
      }
    );
    tiles.addTo(map);

    async function loadBuildings() {
        const res = await fetch('/assets/buildings.geojson');
        const geojson = await res.json();

        L.geoJSON(geojson, {
            style: {
                color: '#0057b8',
                weight: 2,
                fillOpacity: 0.4
            },
            onEachFeature: (feature, layer) => {
                const p = feature.properties;

                const floorsHtml = (p.floors || [])
                    .map(
                        (img, i) =>
                            `<div>
                               <strong>Floor ${i + 1}</strong><br/>
                               <img src="${img}" style="width:200px; margin-top:4px;" />
                             </div>`
                    )
                    .join('<hr/>');

                const popupHtml = `
                    <h3>${p.name}</h3>
                    <p><strong>Opening hours:</strong><br/>${p.opening_hours}</p>
                    ${floorsHtml}
                `;

                layer.bindPopup(popupHtml);
            }
        }).addTo(map);
    }

    loadBuildings();

    // 3) Click to add a marker
    let marker;
    map.on('click', (e) => {
      if (marker) map.removeLayer(marker);
      marker = L.marker(e.latlng).addTo(map);
    });

    // 4) Simple Nominatim geocode (for demos; add rate limit handling in real apps)
    async function geocode(q) {
      const url = new URL('https://nominatim.openstreetmap.org/search');
      url.searchParams.set('q', q);
      url.searchParams.set('format', 'json');
      url.searchParams.set('addressdetails', '1');
      url.searchParams.set('limit', '1');

      const res = await fetch(url, {
        headers: { 'Accept-Language': 'en' },
      });
      if (!res.ok) throw new Error('Geocode failed');
      const data = await res.json();
      return data[0]; // best match
    }

    document.getElementById('searchBtn').onclick = async () => {
      const q = document.getElementById('q').value.trim();
      if (!q) return;
      try {
        const r = await geocode(q);
        if (!r) return alert('No results');
        const lat = parseFloat(r.lat), lon = parseFloat(r.lon);
        map.setView([lat, lon], 15);
        if (marker) map.removeLayer(marker);
        marker = L.marker([lat, lon]).addTo(map)
                 .bindPopup(r.display_name).openPopup();
      } catch (e) {
        alert('Search error: ' + e.message);
      }
    };

    // 5) Overpass API example: fetch nearby cafes within map bounds
    async function fetchCafes() {
      const b = map.getBounds();
      const bbox = `${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()}`;
      const query = `
        [out:json][timeout:25];
        (
          node["amenity"="cafe"](${bbox});
          way["amenity"="cafe"](${bbox});
          relation["amenity"="cafe"](${bbox});
        );
        out center;
      `;
      const res = await fetch('https://overpass-api.de/api/interpreter', {
        method: 'POST',
        body: query,
        headers: { 'Content-Type': 'text/plain' }
      });
      const data = await res.json();
      // Render
      data.elements.forEach(el => {
        const lat = el.lat || el.center?.lat;
        const lon = el.lon || el.center?.lon;
        if (lat && lon) {
          L.circleMarker([lat, lon], { radius: 5, color: '#d33' })
            .addTo(map)
            .bindPopup(el.tags?.name || 'Cafe');
        }
      });
    }

    map.on('moveend', () => {
      // Debounce in real apps; careful with Overpass rate limits
      fetchCafes().catch(console.error);
    });
</script>
</body>
</html>